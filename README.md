# CGproj-lathe

2020CG Proj

## 11.28 1:57A.M

导入了Miku，我也不知道我为什么做这个。

## 0.信息说明

1.操作说明：
WSAD：视角空间位置上下左右移动
鼠标控制视角朝向
数字键1、2：切换工件材质，这里是木头和银之间切换
B：切换到bezier曲线切割模式
P：输出当前零件的点集到文本文件（./data.dat）
R：重新开始
方向键上下左右：手动切割模式下控制刀具移动

## 1.环境配置

环境是VS2019，采用本地opengl库，路径为D:\OpenGL\include与D:\OpenGL\Libs，引入的库我会一并打包上传。

## 2.场景搭建

### 天空盒

skybox，根据learnOpenGL网站教程在项目中构建了一个天空盒，封装到了skybox.h文件中定义细节。
实现原理：构建一个立方体，六个面贴好贴图，为了不令主视角移动影响到天空盒的渲染，对view矩阵转置到3x3再转回4x4去掉移动产生的分量，这样无论如何移动，天空盒看上去距离都不会变化。渲染天空盒时禁用深度写入，这样永远是天空盒显示在其他物体之后。

### 车床

cgmodel网上找了个免费的车床model，用model.h导入到项目中来了，导入过程同样是参考了learnOpenGL网站教程。

### 零件

实现思路：
依靠算法生成一个点集，记录零件的空间信息，我这里记录了pos，normal，polished_bit，分别记录空间坐标，点向量，打磨状态（被切割的地方会更光滑）。之后根据这个点集来渲染我们的圆柱形工件。

核心算法：cylinder_data_update()
我们将圆柱在x,y方向上分段，视精度分成多段，比如分成X，Y段。
  
计算坐标：
对于（x，y）段，计算其对应的空间点坐标（xpos,ypos,zpos）
xPos = cos(2π(x/X)) 
yPos = y/Y
zPos = sin(2π(x/X))
同时全局维护一个数组radius[]来记录圆柱工件某个y段对应的半径r，这样就可以放缩某一段圆柱的半径r，我们可以通过同样的方式修改圆柱的长度。

计算面的点序以及面的法向量：
一个面由两个三角形共六个点（四个不同点）构成，法向量我们只用算一次，按照

r ⃑=((AB) ⃗×(AC) ⃗)/‖(AB) ⃗∙(AC) ⃗ ‖ 

确定六个点，随后计算一个三角形两条向量不为零的边，计算法向量，输入到我们的点集中，同一个法向量夹杂坐标输入六次。

计算polished_bit：
依据radius集合来确认当前段位置切割情况，半径越小说明切的越多，要改光照效果。

### 光源

全场只有一个光源，建立了一个lightCubeShader来管理光源的渲染逻辑。

## 3.切削

我在processInput()函数中针对按键事件来进行切削触发。只有在检测到刀具和工件有接触时，才会调用函数进行数据更新，重新生成圆柱数据集。并且传值到fragment shader改变渲染效果，同时在刀具当前位置生成切削废料。

## 4.粒子系统

粒子系统我写了一个类来封装，首先我定义了每个粒子应该有的属性，我设定了空间位置、速度、大小、生命周期。
然后在头文件particlesystem.h中封装了ParticleSystem类，它的作用在于它内部存储了一个vector用于记录当前空间所有粒子的信息，通过update()函数来获取变化时间deltaTime作为参数，更新所有粒子的信息，如果某个粒子生命周期到了，就将它从vector中删除，同样粒子们速度和坐标位置也会更新，启用重力加速度是的粒子做抛物线运动。在切削时刀具位置处会创建粒子，并且会依据切削掉的半径多少生成不同大小且不同数量的粒子，更为逼真。

## 5.三次Bezier曲线切割

原理：将圆柱面上半截面映射到（-1，1）（-1，1）的二维坐标上，计算bezier曲线将曲线数据再映射回圆柱坐标，然后修改对应位置的radiu半径集合，然后更新圆柱数据，渲染被切割后的圆柱。

## 6.其他功能/细节

### 1.你可以将切割好的模型数据集合保存到本地文件，保存的数据通过加载可以二次打开。

### 2.切削产生的粒子效果和根据当前选择的材料同步。

### 3.可以调参提升模型精细程度，也可以调低模型精细度提高运行帧数。
